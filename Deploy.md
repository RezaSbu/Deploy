# راهنمای جامع دیپلوی پروژه‌های وب

این文档 به شما کمک می‌کند تا با سه معماری مختلف برای استقرار (دیپلوی) پروژه‌های وب آشنا شوید و بتوانید بر اساس نیاز خود، بهترین روش را انتخاب کنید. در ادامه، هر سه روش به صورت کامل توضیح داده شده است که شامل معماری فنی، مزایا و معایب، مراحل دیپلوی و نحوه تنظیم دامنه شخصی می‌شود.

---

## ۱. روش اول: معماری ساده (بک‌اند و فرانت‌اند جدا)

### ۱.۱ معماری فنی

در این روش، بک‌اند و فرانت‌اند به صورت کاملاً جداگانه مستقر می‌شوند. فرانت‌اند به صورت فایل‌های استاتیک (HTML، CSS، JavaScript) در یک وب‌سرور قرار می‌گیرد و بک‌اند به صورت یک سرویس مستقل روی یک سرور یا پلتفرم اجرا می‌شود. این روش، روش سنتی و کلاسیک توسعه وب است که سال‌ها مورد استفاده قرار گرفته است.

در این معماری، فرانت‌اند با استفاده از دستور `npm run build` به فایل‌های استاتیک تبدیل می‌شود و این فایل‌ها روی یک وب‌سرور مثل Nginx، Apache یا حتی هاست اشتراکی آپلود می‌شوند. بک‌اند اما به صورت یک برنامه Node.js در حال اجرا است که درخواست‌های API را پردازش می‌کند و با دیتابیس ارتباط برقرار می‌کند. این دو بخش از طریق اینترنت و با استفاده از پروتکل HTTP با هم ارتباط برقرار می‌کنند.

ارتباط بین فرانت‌اند و بک‌اند از طریق URL بک‌اند انجام می‌شود. مثلاً اگر فرانت‌اند روی دامنه `app.example.com` باشد و بک‌اند روی `api.example.com`، در کد فرانت‌اند باید آدرس کامل بک‌اند را مشخص کنید تا درخواست‌ها به درستی ارسال شوند. این جداسازی باعث می‌شود که هر بخش بتواند به صورت مستقل مقیاس‌دهی (Scale) شود و توسعه‌دهندگان بتوانند روی بخش‌های مختلف به صورت موازی کار کنند.

### ۱.۲ نمودار معماری

```
                        ┌─────────────────────────────────────────────────────────┐
                        │                    اینترنت                               │
                        └─────────────────────────────────────────────────────────┘
                                                 │
                   ┌─────────────────────────────┴─────────────────────────────┐
                   │                                                         │
           ┌───────▼───────┐                                       ┌────────────▼────────┐
           │   کاربر      │                                       │    کاربر            │
           │  (مرورگر)    │                                       │   (مرورگر)           │
           └───────┬───────┘                                       └───────────▲────────┘
                   │                                                         │
                   │ HTTP/HTTPS                                             │ HTTP/HTTPS
                   │                                                         │
                   ▼                                                         │
           ┌───────────────┐                                       ┌────────────▼────────┐
           │   Nginx       │                                       │   PM2/Supervisor    │
           │   (پورت 80)   │                                       │   (پورت 8000)       │
           │               │                                       │                    │
           │  فایل‌های     │                                       │  Node.js + Express  │
           │  استاتیک     │                                       │                    │
           │  build/       │                                       │  ────────────────  │
           └───────┬───────┘                                       │  │ Supabase API │  │
                   │                                               │  └───────────────  │
                   │                                               └───────────▲────────┘
                   │                                                       │
                   ▼                                                       │
           ┌───────────────┐                                       ┌────────────▼────────┐
           │  CORS تنظیم   │                                       │    Supabase         │
           │  شده در Nginx │                                       │    (دیتابیس)        │
           └───────────────┘                                       └─────────────────────┘
```

### ۱.۳ مزایا

این روش مزایای متعددی دارد که آن را به یک انتخاب محبوب تبدیل کرده است. اولاً، این روش کاملاً شناخته شده است و منابع آموزشی فراوانی برای آن وجود دارد. اگر مشکلی پیش بیاید، به راحتی می‌توانید راه‌حل را در اینترنت پیدا کنید. ثانیاً، انعطاف‌پذیری بالایی دارد و می‌توانید هر بخش را به صورت جداگانه پیکربندی و بهینه‌سازی کنید. ثالثاً، کنترل کامل روی سرور دارید و می‌توانید هر تغییری که نیاز دارید اعمال کنید.

از نظر هزینه نیز این روش می‌تواند مقرون به صرفه باشد، به خصوص اگر از سرویس‌های رایگان یا ارزان برای بک‌اند استفاده کنید. پلتفرم‌هایی مثل Render، Railway و Heroku لایه رایگان دارند که برای پروژه‌های کوچک کافی است. همچنین، در این روش می‌توانید از CDN برای فایل‌های استاتیک استفاده کنید که سرعت بارگذاری را به طور چشمگیری افزایش می‌دهد.

### ۱.۴ معایب

با وجود مزایا، این روش معایبی هم دارد که باید در نظر گرفته شوند. پیچیدگی مدیریت یکی از مهم‌ترین معایب است. شما باید دو محیط مختلف را مدیریت کنید و تنظیمات هر کدام را به صورت جداگانه نگهداری کنید. این موضوع می‌تواند در پروژه‌های بزرگ به یک کابوس تبدیل شود. مشکل محیط یکسان (Consistent Environment) نیز وجود دارد؛ ممکن است کد روی سیستم شما درست کار کند اما روی سرور به دلیل تفاوت در نسخه‌های Node.js یا پکیج‌ها دچار مشکل شود.

هزینه سرورهای جداگانه یکی دیگر از معایب است. اگر بخواهید بک‌اند و فرانت‌اند را روی سرورهای جداگانه اجرا کنید، باید دو بار هزینه پرداخت کنید. تنظیم دستی CORS نیز می‌تواند دردسرساز باشد و اگر به درستی انجام نشود، ارتباط بین فرانت‌اند و بک‌اند قطع می‌شود. در نهایت، مدیریت پروسه بک‌اند با ابزارهایی مثل PM2 نیاز به دانش فنی دارد و باید به صورت مداوم مانیتورینگ انجام شود.

### ۱.۵ مراحل دیپلوی

#### مرحله اول: آماده‌سازی فرانت‌اند

ابتدا باید فرانت‌اند را آماده کنید. وارد پوشه فرانت‌اند شوید و وابستگی‌ها را نصب کنید. سپس با استفاده از دستور `npm run build`، پروژه را بسازید. این دستور فایل‌های بهینه‌شده و فشرده‌شده را در پوشه `build` قرار می‌دهد که آماده انتشار هستند. پس از اتمام بیلد، می‌توانید فایل‌های موجود در پوشه `build` را روی هاست خود آپلود کنید.

```bash
cd FrontEnd
npm install
npm run build
```

پس از اجرای این دستورات، پوشه‌ای به نام `build` در کنار پوشه `src` ایجاد می‌شود. محتوای این پوشه شامل فایل `index.html` و پوشه `static` است که تمام فایل‌های CSS، JavaScript و تصاویر بهینه‌شده در آن قرار دارند. این فایل‌ها آماده بارگذاری روی وب‌سرور هستند و نیازی به Node.js روی سرور مقصد ندارند.

#### مرحله دوم: استقرار فرانت‌اند روی وب‌سرور

برای استقرار فرانت‌اند، چند گزینه دارید. اگر از VPS استفاده می‌کنید، باید Nginx را نصب و پیکربندی کنید. فایل‌های بیلد را در مسیر `/var/www/html` کپی کنید و تنظیمات Nginx را انجام دهید. اگر از هاست اشتراکی استفاده می‌کنید، می‌توانید فایل‌ها را مستقیماً از طریق FileZilla یا FTP آپلود کنید. برخی پلتفرم‌ها مثل Vercel و Netlify نیز گزینه‌های خوبی برای استقرار فرانت‌اند هستند و به صورت خودکار از React پشتیبانی می‌کنند.

```bash
# نصب Nginx روی سرور
sudo apt update
sudo apt install nginx

# کپی فایل‌های بیلد
sudo cp -r build/* /var/www/html/

# تنظیم ownership
sudo chown -R www-data:www-data /var/www/html/
```

#### مرحله سوم: استقرار بک‌اند

برای بک‌اند، وارد پوشه Backend شوید و فایل‌ها را به سرور مقصد منتقل کنید. روی سرور، Node.js و npm را نصب کنید و وابستگی‌ها را نصب کنید. برای اجرای مداوم بک‌اند، از PM2 استفاده کنید که یک Process Manager برای Node.js است و مطمئن می‌شود برنامه همیشه در حال اجرا باشد. اگر از پلتفرم‌های ابری مثل Railway یا Render استفاده می‌کنید، کافیست مخزن Git را متصل کنید و آن‌ها به صورت خودکار برنامه را استقرار می‌دهند.

```bash
# نصب PM2
sudo npm install -g pm2

# اجرای برنامه با PM2
pm2 start server.js --name "backend"

# تنظیم اجرای خودکار پس از ری‌استارت
pm2 startup
pm2 save
```

#### مرحله چهارم: تنظیم متغیرهای محیطی

متغیرهای محیطی را در فایل `.env` روی سرور تنظیم کنید. این فایل شامل اطلاعات حساس مثل کلیدهای API است و نباید در مخزن Git قرار بگیرد. در پلتفرم‌های ابری، این متغیرها از طریق پنل تنظیمات اضافه می‌شوند.

```env
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_KEY=your-service-role-key
PORT=8000
```

### ۱.۶ تنظیم دامنه شخصی

#### تنظیم Nginx برای فرانت‌اند

یک فایل پیکربندی در Nginx بسازید که درخواست‌های ورودی را به فایل‌های استاتیک هدایت کند. این تنظیم شامل تعیین ریشه سند (Document Root)، فایل ایندکس و تنظیمات کش برای بهبود عملکرد است.

```nginx
server {
    listen 80;
    server_name app.example.com www.app.example.com;
    root /var/www/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    # کش فایل‌های استاتیک
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

#### تنظیم Nginx برای بک‌اند

برای بک‌اند، یک ساب‌دامین جداگانه بسازید و Nginx را به عنوان Reverse Proxy تنظیم کنید. این تنظیم باعث می‌شود درخواست‌های API به درستی به برنامه Node.js هدایت شوند.

```nginx
server {
    listen 80;
    server_name api.example.com;

    location / {
        proxy_pass http://localhost:8000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
    }
}
```

پس از ایجاد این فایل‌ها، باید آن‌ها را به پوشه `sites-enabled` لینک کنید و Nginx را ری‌استارت کنید. همچنین، در پنل دامنه خود، رکوردهای A یا CNAME را برای هر دو دامنه تنظیم کنید تا به آدرس IP سرور اشاره کنند.

```bash
sudo ln -s /etc/nginx/sites-available/frontend /etc/nginx/sites-enabled/
sudo ln -s /etc/nginx/sites-available/backend /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl restart nginx
```

---

## ۲. روش دوم: معماری داکرایز شده (Docker/Docker Compose)

### ۲.۱ معماری فنی

داکرایز کردن پروژه به معنای بسته‌بندی تمام بخش‌های برنامه در کانتینرهای Docker است. این روش تضمین می‌کند که برنامه در هر محیطی به یک شکل اجرا شود. در این معماری، فرانت‌اند و بک‌اند هر کدام در کانتینر جداگانه اجرا می‌شوند و Docker Compose مدیریت ارتباط بین آن‌ها را بر عهده دارد. فرانت‌اند در یک کانتینر Nginx قرار می‌گیرد که فایل‌های استاتیک را سرو می‌کند و بک‌اند در یک کانتینر Node.js اجرا می‌شود.

یکی از مزایای بزرگ Docker، جداسازی محیط‌ها است. هر کانتینر محیط ایزوله خود را دارد و تداخلی بین وابستگی‌های مختلف ایجاد نمی‌شود. این موضوع به ویژه در پروژه‌هایی که چندین توسعه‌دهنده روی آن کار می‌کنند بسیار مهم است. همه توسعه‌دهندگان دقیقاً یک محیط یکسان دارند و مشکلات "روی سیستم من کار می‌کند" حل می‌شود.

Docker Compose ابزاری است که امکان تعریف و اجرای چند کانتینر را با هم فراهم می‌کند. با یک فایل YAML ساده، می‌توانید تعریف کنید که کدام سرویس‌ها باید اجرا شوند، چگونه به هم متصل شوند و چه پورت‌هایی در دسترس باشند. این فایل مستند کاملی از محیط اجرا است که هر کسی می‌تواند با خواندن آن، برنامه را اجرا کند.

### ۲.۲ نمودار معماری

```
                    ┌─────────────────────────────────────────────────────────────┐
                    │                      سرور فیزیکی / VPS                       │
                    │                                                             │
                    │   ┌─────────────────────────────────────────────────────┐   │
                    │   │                   Docker Engine                      │   │
                    │   │                                                     │   │
                    │   │   ┌───────────────────────────────────────────────┐ │   │
                    │   │   │            Docker Network                      │ │   │
                    │   │   │            user-form-network                   │ │   │
                    │   │   └───────────────────────────────────────────────┘ │   │
                    │   │              │                         │             │   │
                    │   │              │                         │             │   │
                    │   │     ┌────────▼────────┐      ┌────────▼────────┐    │   │
                    │   │     │  frontend       │      │  backend        │    │   │
                    │   │     │  Container      │      │  Container      │    │   │
                    │   │     │                 │      │                 │    │   │
                    │   │     │ Nginx :80       │      │ Node.js :8000   │    │   │
                    │   │     └────────┬────────┘      └────────┬────────┘    │   │
                    │   │              │                         │             │   │
                    │   │              │                         │             │   │
                    │   │              ▼                         ▼             │   │
                    │   │     ┌────────────────┐      ┌────────────────┐      │   │
                    │   │     │   build/       │      │   Supabase     │      │   │
                    │   │     │   (Static)     │      │   (External)   │      │   │
                    │   │     └────────────────┘      └────────────────┘      │   │
                    │   │                                                     │   │
                    │   └─────────────────────────────────────────────────────┘   │
                    │                                                             │
                    │        ┌────────────────┐        ┌────────────────┐        │
                    │        │   Port 3000    │        │   Port 8000    │        │
                    │        │   (Host)       │        │   (Host)       │        │
                    │        └───────┬────────┘        └───────┬────────┘        │
                    │                │                          │                 │
                    └────────────────┼──────────────────────────┼─────────────────┘
                                     │                          │
                                     ▼                          ▼
                        ┌────────────────────┐        ┌────────────────────┐
                        │   دامنه اصلی       │        │   ساب‌دامین API    │
                        │   app.example.com  │        │   api.example.com  │
                        └────────────────────┘        └────────────────────┘
```

### ۲.۳ مزایا

داکرایز کردن مزایای فراوانی دارد که آن را به انتخابی محبوب در توسعه مدرن تبدیل کرده است. محیط یکسان مهم‌ترین مزیت است؛ برنامه در محیط توسعه، تست و تولید به یک شکل اجرا می‌شود. این موضوع احتمال خطا را به حداقل می‌رساند و توسعه‌دهندگان می‌توانند با اطمینان بیشتری کار کنند. جداسازی کامل (Isolation) نیز یکی دیگر از مزایای بزرگ است. هر سرویس در کانتینر جداگانه اجرا می‌شود و تغییر در یک سرویس تأثیری روی سرویس‌های دیگر ندارد.

مقیاس‌پذیری (Scalability) در Docker بسیار ساده است. اگر نیاز به مقیاس‌دهی بک‌اند دارید، کافیست تعداد کانتینرها را افزایش دهید و Docker Compose یا Kubernetes مدیریت بار را انجام می‌دهد. سرعت استقرار (Deployment Speed) نیز با Docker به مراتب بیشتر است. تمام وابستگی‌ها در یک Image بسته‌بندی می‌شوند و نیازی به نصب جداگانه روی سرور نیست. در نهایت، مدیریت ساده با یک دستور (`docker-compose up -d`) امکان‌پذیر است که کار را برای تیم‌های توسعه بسیار راحت می‌کند.

### ۲.۴ معایب

با وجود مزایای فراوان، Docker معایبی هم دارد که باید در نظر گرفته شوند. منابع سیستم (CPU و RAM) بیشتر مصرف می‌شود چون هر کانتینر سربار (Overhead) خود را دارد. این موضوع به ویژه در سرورهای با منابع محدود می‌تواند مشکل‌ساز باشد. منحنی یادگیری (Learning Curve) نیز وجود دارد و تیم باید زمان بگذارد تا با مفاهیم Docker آشنا شود.

پیچیدگی اولیه در تنظیم Dockerfile و docker-compose.yml یکی دیگر از معایب است. نوشتن این فایل‌ها نیاز به دانش فنی دارد و ممکن است برای توسعه‌دهندگان مبتدی گیج‌کننده باشد. اندازه Image‌ها نیز می‌تواند بزرگ باشد اگر به درستی بهینه‌سازی نشوند. استفاده از Image‌های Alpine می‌تواند این مشکل را تا حد زیادی حل کند. در نهایت، وابستگی به Docker Engine وجود دارد و اگر Docker روی سرور به درستی کار نکند، کل برنامه از کار می‌افتد.

### ۲.۵ مراحل دیپلوی

#### مرحله اول: آماده‌سازی فایل‌های Docker

برای داکرایز کردن، باید Dockerfile برای هر بخش بسازید. بک‌اند از Node.js Alpine استفاده می‌کند که یک Image بسیار سبک است. فرانت‌اند اما در دو مرحله بیلد می‌شود؛ اول Node.js برای ساخت فایل‌ها و سپس Nginx برای سرو کردن آن‌ها. این روش Multi-stage Build نامیده می‌شود و Image نهایی را به حداقل می‌رساند.

```dockerfile
# Backend/Dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install --production
COPY . .
EXPOSE 8000
CMD ["npm", "start"]
```

```dockerfile
# FrontEnd/Dockerfile
# مرحله اول: بیلد
FROM node:18-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# مرحله دوم: Nginx
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

#### مرحله دوم: تنظیم Docker Compose

فایل `docker-compose.yml` را در پوشه اصلی پروژه بسازید. این فایل تعریف می‌کند که کدام سرویس‌ها باید اجرا شوند، چگونه به هم متصل شوند و چه پورت‌هایی در دسترس باشند.

```yaml
version: '3.8'

services:
  backend:
    build: ./Backend
    container_name: user-form-backend
    restart: unless-stopped
    ports:
      - "8000:8000"
    env_file:
      - ./Backend/.env
    networks:
      - user-form-network

  frontend:
    build: ./FrontEnd
    container_name: user-form-frontend
    restart: unless-stopped
    ports:
      - "3000:80"
    depends_on:
      - backend
    networks:
      - user-form-network

networks:
  user-form-network:
    driver: bridge
```

#### مرحله سوم: اجرای پروژه

با یک دستور ساده، تمام کانتینرها ساخته و اجرا می‌شوند. اولین بار کمی زمان می‌برد چون Image‌های پایه دانلود می‌شوند.

```bash
# ساخت و اجرا
docker-compose up --build

# اجرا در پس‌زمینه
docker-compose up -d --build
```

پس از اجرا، می‌توانید وضعیت کانتینرها را بررسی کنید و از درست کار کردن برنامه اطمینان حاصل کنید.

```bash
# مشاهده وضعیت کانتینرها
docker-compose ps

# مشاهده لاگ‌ها
docker-compose logs -f
```

### ۲.۶ تنظیم دامنه شخصی

#### نصب و تنظیم Nginx به عنوان Reverse Proxy

Nginx را روی سرور نصب کنید و پیکربندی کنید که درخواست‌های ورودی را به کانتینرها هدایت کند. این تنظیم شامل دو بخش است؛ یکی برای دامنه اصلی (فرانت‌اند) و دیگری برای ساب‌دامین (بک‌اند).

```bash
sudo apt install nginx
sudo nano /etc/nginx/sites-available/user-form-project
```

```nginx
# فرانت‌اند
server {
    listen 80;
    server_name app.example.com www.app.example.com;

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}

# بک‌اند
server {
    listen 80;
    server_name api.example.com;

    location / {
        proxy_pass http://localhost:8000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

#### فعال‌سازی و ری‌استارت Nginx

پس از ایجاد فایل پیکربندی، آن را فعال کنید و Nginx را ری‌استارت کنید. همچنین، مطمئن شوید که فایل پیش‌فرض غیرفعال شده تا تداخل ایجاد نشود.

```bash
sudo ln -s /etc/nginx/sites-available/user-form-project /etc/nginx/sites-enabled/
sudo rm /etc/nginx/sites-enabled/default
sudo nginx -t
sudo systemctl restart nginx
```

#### اضافه کردن گواهی SSL (اختیاری اما پیشنهادی)

برای امن کردن ارتباط، می‌توانید از گواهی SSL رایگان Let's Encrypt استفاده کنید. Certbot به صورت خودکار گواهی را دریافت و تنظیم می‌کند.

```bash
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d app.example.com -d www.app.example.com
sudo certbot --nginx -d api.example.com
```

---

## ۳. روش سوم: Backend as a Service (BaaS)

### ۳.۱ معماری فنی

Backend as a Service (BaaS) یک معماری مدرن است که در آن بخش بک‌اند به صورت کامل به یک سرویس خارجی برون‌سپاری می‌شود. به جای نوشتن و مدیریت سرور، شما از API‌های آماده استفاده می‌کنید که توسط پلتفرم‌هایی مثل Supabase، Firebase یا Appwrite ارائه می‌شود. این پلتفرم‌ها تمام کارهای سروری را انجام می‌دهند؛ از جمله احراز هویت، دیتابیس، ذخیره‌سازی فایل، توابع ابری (Cloud Functions) و Real-time updates.

Supabase یک جایگزین متن‌باز برای Firebase است که روی PostgreSQL ساخته شده است. این پلتفرم تمام ویژگی‌های مورد نیاز برای یک اپلیکیشن مدرن را فراهم می‌کند: دیتابیس PostgreSQL، احراز هویت (Email/Password، OAuth، Magic Link)، Storage برای فایل‌ها، Edge Functions برای منطق سمت سرور، و Realtime subscriptions برای به‌روزرسانی زنده.

در این معماری، شما فقط فرانت‌اند را توسعه و استقرار می‌دهید. بک‌اند کاملاً توسط Supabase مدیریت می‌شود و شما فقط از طریق API با آن ارتباط برقرار می‌کنید. این موضوع سرعت توسعه را به شدت افزایش می‌دهد و نگرانی‌های مربوط به سرور، امنیت و مقیاس‌پذیری را کاهش می‌دهد.

### ۳.۲ نمودار معماری

```
                        ┌─────────────────────────────────────────────────────────┐
                        │                    اینترنت                               │
                        └─────────────────────────────────────────────────────────┘
                                                 │
                   ┌─────────────────────────────┴─────────────────────────────┐
                   │                                                         │
           ┌───────▼───────┐                                       ┌────────────▼────────┐
           │   کاربر      │                                       │    کاربر            │
           │  (مرورگر)    │                                       │   (مرورگر)           │
           └───────┬───────┘                                       └───────────▲────────┘
                   │                                                         │
                   │ HTTPS                                                   │ HTTPS
                   │                                                         │
                   ▼                                                         │
           ┌───────────────┐                                       ┌────────────▼────────┐
           │    CDN        │                                       │   Supabase API      │
           │  (Vercel/     │◄──────────────────────────────────────│   (دیتابیس +        │
           │   Netlify)    │           REST API / GraphQL          │    Auth + Storage)  │
           │               │                                       │                     │
           │  ┌─────────┐  │                                       │  ┌────────────────┐ │
           │  │ React   │  │                                       │  │ PostgreSQL     │ │
           │  │ App     │  │                                       │  │ Auth Service   │ │
           │  └─────────┘  │                                       │  │ Storage        │ │
           └───────┬───────┘                                       │  │ Edge Functions │ │
                   │                                               │  └────────────────┘ │
                   │                                               └───────────▲────────┘
                   │                                                       │
                   ▼                                                       │
           ┌───────────────┐                                       ┌────────────▼────────┐
           │  دامنه        │                                       │    Supabase         │
           │  app.example. │                                       │    Dashboard        │
           │  com          │                                       │    (مدیریت دیتابیس) │
           └───────────────┘                                       └─────────────────────┘
```

### ۳.۳ مزایا

سرعت توسعه باورنکردنی مهم‌ترین مزیت BaaS است. به جای هفته‌ها کار روی بک‌اند، می‌توانید در چند ساعت یک اپلیکیشن کامل بسازید. تمام سرویس‌های پایه (دیتابیس، احراز هویت، ذخیره‌سازی) آماده هستند و فقط کافیست از آن‌ها استفاده کنید. کاهش هزینه‌ها نیز قابل توجه است؛ برای پروژه‌های کوچک و متوسط، لایه رایگان Supabase کافی است و نیازی به پرداخت ماهانه نیست.

مقیاس‌پذیری خودکار یکی دیگر از مزایای بزرگ است. Supabase به صورت خودکار مقیاس‌دهی می‌کند و شما نگران overload شدن سرور نیستید. امنیت نیز توسط تیم متخصص Supabase مدیریت می‌شود و شما از بهترین شیوه‌های امنیتی بهره‌مند می‌شوید. در نهایت، نگهداری ساده است چون هیچ سروری برای مدیریت وجود ندارد و تمام به‌روزرسانی‌ها به صورت خودکار انجام می‌شود.

### ۳.۴ معایب

وابستگی به سرویس خارجی (Vendor Lock-in) یکی از معایب اصلی است. اگر بخواهید از Supabase به پلتفرم دیگری مهاجرت کنید، ممکن است دشوار باشد چون کد شما با API خاص Supabase کوئری می‌شود. محدودیت‌های لایه رایگان نیز وجود دارد؛ برای پروژه‌های بزرگ، باید هزینه پرداخت کنید که ممکن است گران‌تر از VPS شخصی باشد.

کنترل کمتر روی سرور یکی دیگر از معایب است. شما نمی‌توانید تنظیمات سرور را تغییر دهید و باید با محدودیت‌های پلتفرم کنار بیایید. مسائل مربوط به حریم خصوصی و محل داده‌ها نیز وجود دارد؛ داده‌های شما روی سرورهای Supabase ذخیره می‌شوند و باید به آن‌ها اعتماد کنید. در نهایت، برای منطق پیچیده سمت سرور، Edge Functions ممکن است کافی نباشد و نیاز به راه‌حل‌های دیگری باشد.

### ۳.۵ مراحل دیپلوی

#### مرحله اول: راه‌اندازی Supabase

ابتدا یک حساب کاربری در Supabase بسازید و یک پروژه جدید ایجاد کنید. در فرآیند ایجاد پروژه، Supabase به طور خودکار یک دیتابیس PostgreSQL، تنظیمات احراز هویت و یک API key برای شما ایجاد می‌کند. پس از ایجاد پروژه، می‌توانید از بخش SQL Editor جداول مورد نیاز خود را بسازید.

```sql
-- ایجاد جدول کاربران
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    full_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    age INTEGER NOT NULL
);

-- فعال‌سازی RLS (Row Level Security)
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- سیاست‌های امنیتی
CREATE POLICY "Allow public read" ON users FOR SELECT USING (true);
CREATE POLICY "Allow public insert" ON users FOR INSERT WITH CHECK (true);
```

#### مرحله دوم: نصب کلاینت Supabase

کلاینت Supabase را در پروژه فرانت‌اند نصب کنید. این کلاینت امکان ارتباط آسان با Supabase API را فراهم می‌کند.

```bash
npm install @supabase/supabase-js
```

#### مرحله سوم: پیکربندی در کد فرانت‌اند

یک فایل تنظیم بسازید که اطلاعات اتصال به Supabase را در خود داشته باشد. این اطلاعات را از پنل Supabase دریافت کنید.

```javascript
// supabaseClient.js
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = 'https://your-project.supabase.co'
const supabaseKey = 'your-anon-key'

export const supabase = createClient(supabaseUrl, supabaseKey)
```

#### مرحله چهارم: استقرار فرانت‌اند

فرانت‌اند را می‌توانید روی هر پلتفرمی که از برنامه‌های استاتیک پشتیبانی می‌کند مستقر کنید. Vercel و Netlify گزینه‌های عالی برای React هستند و با GitHub یکپارچه می‌شوند.

```bash
# استقرار روی Vercel
vercel

# یا استقرار روی Netlify
netlify deploy --prod --dir=build
```

### ۳.۶ تنظیم دامنه شخصی

#### تنظیم دامنه در Vercel

اگر از Vercel استفاده می‌کنید، در پنل تنظیمات پروژه، به بخش Domains بروید و دامنه خود را اضافه کنید. Vercel به طور خودکار DNS را پیکربندی می‌کند و گواهی SSL را صادر می‌کند.

```bash
vercel domains add app.example.com
```

#### تنظیم دامنه در Netlify

در Netlify، به بخش Domain Management بروید و دامنه خود را اضافه کنید. Netlify DNS را به صورت خودکار تنظیم می‌کند یا می‌توانید از DNS Provider خود استفاده کنید.

```bash
netlify domains add app.example.com
```

#### تنظیم DNS در دامنه

در پنل دامنه خود (مثلاً Godaddy، Namecheap یا Cloudflare)، رکوردهای DNS را تنظیم کنید تا به آدرس پروژه روی Vercel یا Netlify اشاره کنند.

---

## ۴. مقایسه کلی سه روش

### ۴.۱ جدول مقایسه

| معیار | روش ساده (جدا) | روش Docker | روش BaaS |
|-------|---------------|------------|----------|
| پیچیدگی راه‌اندازی | متوسط | بالا | پایین |
| پیچیدگی مدیریت | بالا | متوسط | پایین |
| هزینه | متوسط | متوسط | کم (تا رایگان) |
| مقیاس‌پذیری | دستی | خوب | عالی |
| کنترل | کامل | کامل | محدود |
| وابستگی خارجی | کم | کم | زیاد |
| سرعت توسعه | متوسط | خوب | عالی |
| یادگیری | آسان | متوسط | آسان |
| مناسب برای | پروژه‌های بزرگ | تیم‌ها | استارتاپ‌ها |

### ۴.۲ جدول هزینه تقریبی

| روش | هزینه ماهانه (تقریبی) |
|-----|----------------------|
| روش ساده (VPS) | ۵ تا ۵۰ دلار |
| روش Docker (VPS) | ۵ تا ۵۰ دلار |
| روش BaaS (Supabase) | ۰ تا ۲۵ دلار |

### ۴.۳ زمان مورد نیاز برای راه‌اندازی

| روش | زمان راه‌اندازی اولیه |
|-----|----------------------|
| روش ساده (جدا) | ۲ تا ۴ ساعت |
| روش Docker | ۱ تا ۲ ساعت |
| روش BaaS | ۱۵ تا ۳۰ دقیقه |

---

## ۵. نتیجه‌گیری و توصیه

انتخاب روش مناسب به شرایط پروژه و تیم بستگی دارد. اگر تازه‌کار هستید و می‌خواهید سریع محصول را بسازید، روش BaaS با Supabase بهترین گزینه است. اگر یک تیم حرفه‌ای دارید و می‌خواهید کنترل کامل روی محیط داشته بید، روش Docker پیشنهاد می‌شود. اگر پروژه بزرگ دارید و نیاز به سفارشی‌سازی‌های زیادی دارید، روش ساده (جدا) می‌تواند مناسب باشد.

برای اکثر پروژه‌های شخصی و استارتاپی، پیشنهاد ما ترکیب روش دوم (Docker) برای توسعه و روش سوم (BaaS) برای دیتابیس است. این ترکیب بهترین تعادل بین سادگی، کنترل و سرعت را ارائه می‌دهد.

---

## ۶. منابع و مطالعه بیشتر

برای یادگیری بیشتر، می‌توانید به منابع زیر مراجعه کنید. مستندات رسمی Docker و Docker Compose اطلاعات کاملی در مورد کانتینرها ارائه می‌دهند. مستندات Supabase نیز منبع عالی برای یادگیری BaaS است. همچنین، کتاب‌ها و دوره‌های آموزشی آنلاین می‌توانند در یادگیری عمیق‌تر این موضوعات مفید باشند.

این راهنما برای شروع کافی است، اما دنیای DevOps و Cloud بسیار گسترده است و همیشه چیزهای جدید برای یادگیری وجود دارد. با تمرین و تجربه، می‌توانید مهارت‌های خود را در این زمینه ارتقا دهید و پروژه‌های حرفه‌ای‌تری بسازید.
